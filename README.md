# 課題 1 - 要件からモデルを考える
- 概念クラス図
  - その意図の解説資料
- 各概念クラスに対する、入出力のインターフェース設計，およびその意図の解説資料

----

# 概念クラス図の解説
## 1. ユーザー クラス
### 役割:
- 映画を観るユーザーの情報を保持し、シニアや未成年かどうかを判定する。

### 意図:
- ユーザーの年齢に基づいて適用可能な割引や制限を確認するためのクラス。
- シニアや未成年の判定メソッドを持つことで、年齢に応じた処理が簡潔に行える。

## 2.チケット クラス
### 役割:
- 映画のチケットに関する情報を管理する。

### 意図:
- チケットの種別と基準価格を管理し、料金計算時に使用するためのクラス。

## 3.上映スケジュール クラス
### 役割:
- 映画の上映日程と残り席数を管理する。

### 意図
- 上映スケジュールの詳細情報を管理し、予約時や割引適用時に使用するためのクラス

## 4.割引 クラス
### 役割
- 各種割引の情報と条件を管理する。

### 意図:
- 各種割引の情報を管理し、適用可能な割引を判定するためのクラス。

## 5,最適スケジュール検索 クラス
### 役割
- 複数の上映スケジュールとユーザーリストから最も安く観覧できるオプションを計算し提供する。

### 意図:
- ユーザーにとって最も経済的な観覧オプションを提供するためのクラス。

## 6.個別価格計算 クラス
### 役割:
- ユーザー、上映スケジュール、および割引リストを基に最終的な料金を計算する。

### 意図:
- 割引適用ロジックを含み、一番安い割引を適用して正確な料金を計算するためのクラス。


## クラス間の関係
### ユーザー と チケット:
- 各ユーザーは1枚のチケットを購入します。チケットの種別に応じて、料金が異なります。

### 上映スケジュール と 割引:
- 各上映スケジュールに対して、適用可能な割引が存在します。割引は特定の条件を満たす場合に適用されます。

### 最適スケジュール検索 と 個別価格計算:
- 最適スケジュール検索クラスは、複数の上映スケジュールの中から、個別価格計算クラスを利用して各ユーザーの料金を計算し、最も安いオプションを見つけ出します。


----

# 各概念クラスに対する、入出力のインターフェース設計，およびその意図の解説
## 1. ユーザー クラス
### インターフェース設計

```javascript
class ユーザー {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  年齢を取得() {
    return this.age;
  }

  シニアかを確認() {
    return this.age >= 60;
  }

  未成年かを確認() {
    return this.age < 18;
  }
}

```
### 入力
- name (String): ユーザーの名前
- age (int): ユーザーの年齢
### 出力
- 年齢を取得(): ユーザーの年齢を返す
- シニアかを確認(): ユーザーがシニアかどうかを判定して返す
- 未成年かを確認(): ユーザーが未成年かどうかを判定して返す

### 意図
- 年齢情報の管理:
  - ユーザーの年齢を基に適用可能な割引を判断する。
- 条件の簡潔な判定:
  - シニアかどうか、未成年かどうかを判定するメソッドを作成することで、各所で年齢判定のロジックを簡潔に記述できる。例）シニアかどうかを判定するために単純に`user.シニアかを確認()`と呼び出すだけで済むため、コードの可読性が向上する。
- 再利用性:
  - 年齢に基づく判断が一箇所に集約されることで、変更があった場合にも対応しやすくなる。
  - 例)シニアの定義が65歳に変更された場合、メソッド内の条件を変更するだけで済む。


## 2. チケット クラス
### インターフェース設計

```javascript
class チケット {
  constructor(type, basePrice) {
    this.type = type;
    this.basePrice = basePrice;
  }

  種別を取得() {
    return this.type;
  }

  基本料金を取得() {
    return this.basePrice;
  }
}
```
### 入力
- type (String): チケットの種別
- basePrice (int): チケットの基準価格

### 出力
- 種別を取得(): チケットの種別を返す
- 基本料金を取得(): チケットの基準価格を返す

### 意図
- 料金情報の管理:
  - 各種チケットの基準価格を保持し、料金計算時に利用する。
  - これにより、異なるチケット種別に応じた料金計算が可能になる。
- 一元管理:
  - チケットの種類とその価格を一元管理することで、管理の容易さと一貫性を保つ。
  - 例えば、チケットの価格変更があった場合、このクラス内でのみ修正を行えば良いので、保守性が向上する。



## 3. 上映スケジュール クラス
### インターフェース設計

```javascript
class 上映スケジュール {
  constructor(date, time, remainingSeats) {
    this.date = date;
    this.time = time;
    this.remainingSeats = remainingSeats;
  }

  日付を取得() {
    return this.date;
  }

  時間を取得() {
    return this.time;
  }

  残り席数を取得() {
    return this.remainingSeats;
  }
}

```

### 入力
- date (Date): 上映日
- time (Time): 上映時間
- remainingSeats (int): 残り席数

### 出力
- 日付を取得(): 上映日を返す
- 時間を取得(): 上映時間を返す
- 残り席数を取得(): 残り席数を返す

### 意図
- スケジュール情報の管理:
  - 各上映スケジュールの詳細情報を保持し、予約時や割引適用時に利用する。
- 席数管理:
  - 残り席数を管理することで、満席かどうかの判定を行い、予約が可能かどうかを判断する。

## 4. 割引 クラス
### インターフェース設計

```javascript
class 割引 {
  constructor(name, discountedPrice, condition) {
    this.name = name;
    this.discountedPrice = discountedPrice;
    this.condition = condition;
  }

  名前を取得() {
    return this.name;
  }

  割引後の料金を取得() {
    return this.discountedPrice;
  }

  適用可能か(user, schedule) {
    const date = schedule.date;
    const time = schedule.time;
    return eval(this.condition);
  }
}

```

### 入力
- name (String): 割引の名前
- discountedPrice (int): 割引適用後の料金
- condition (String): 割引適用条件

### 出力
- 名前を取得(): 割引の名前を返す
- 割引後の料金を取得(): 割引適用後の料金を返す
- 適用可能か(ユーザー, 上映スケジュール): 割引が適用可能かどうかを判定して返す

### 意図
- 割引情報の管理:
  - 各割引の名前、適用後の料金、適用条件を保持し、適用可能な割引を判定するために利用する。
- 条件判定の簡略化:
  - 割引適用条件を持つことで、適用可能かどうかの判定を簡潔に行う。
  - 例)特定の日付や時間に対する割引を適用する場合、`割引.適用可能か(user, schedule)`を呼び出すだけで適用可能かどうかを判定できる。

## 5. 最適スケジュール検索 クラス
### インターフェース設計

```javascript
class 最適スケジュール検索 {
  constructor(schedules, user, discounts) {
    this.schedules = schedules;
    this.user = user;
    this.discounts = discounts;
  }

  最安値オプションを取得(currentDate) {
    let bestOption = null;
    let minTotalPrice = Infinity;

    this.schedules.forEach(schedule => {
      const price = this.個別価格を計算(this.user, schedule);
      if (price !== -1 && price < minTotalPrice) {
        minTotalPrice = price;
        bestOption = { schedule, price };
      }
    });

    return bestOption || { message: '利用可能な上映スケジュールがありません。' };
  }

  個別価格を計算(user, schedule) {
    const calculator = new 個別価格計算();
    return calculator.価格を計算(user, schedule, this.discounts);
  }
}

```

### 入力
- schedules (List<上映スケジュール>): 上映スケジュールのリスト
- user (ユーザー): ユーザー情報
- discounts (List<割引>): 割引のリスト

### 出力
- 最安値オプションを取得(currentDate: DateTime): 最安値の上映スケジュールと料金を返す
- 個別価格を計算(ユーザー, 上映スケジュール): 個別の上映スケジュールに対する最終料金を計算して返す

### 意図
- 最適なスケジュールの選定: 複数の上映スケジュールと割引情報を基に、ユーザーにとって最も経済的な観覧オプションを提供します。これにより、ユーザーは最も安い料金で映画を観ることができます。
- 一元管理: スケジュール、ユーザー、割引情報を一元的に管理し、最適な組み合わせを選出することで、システムの効率を高めます。


## 6. 個別価格計算 クラス
### インターフェース設計

```
class 個別価格計算 {
  価格を計算(user, schedule, discounts) {
    const basePrice = user.未成年かを確認() ? 1000 : 1600;

    if (user.未成年かを確認() && schedule.time >= '20:00') {
      return -1; // 未成年は20時以降入場不可
    }

    let minPrice = basePrice;

    discounts.forEach(discount => {
      if (discount.適用可能か(user, schedule)) {
        minPrice = Math.min(minPrice, discount.discountedPrice);
      }
    });

    return minPrice;
  }
}
```

### 入力
- user (ユーザー): ユーザー情報
- schedule (上映スケジュール): 上映スケジュール情報
- discounts (List<割引>): 割引のリスト

### 出力
- 価格を計算(ユーザー, 上映スケジュール, 割引リスト): 最終料金を計算して返す

### 意図
- 料金計算の統合:
  - 各ユーザーに対する最終料金を計算し、割引を適用して最も安い価格を提供する。
- 割引適用ロジックの一元化:
  - 割引適用のロジックをこのクラスにまとめることで、割引の適用条件が変更された場合にも、対応が容易になる。


-----

# 課題 2 - 考えたモデルをシステムとして実装する
## この課題の想定成果物：
- localhostで動作確認可能なソースコード
- 3rd Party のフレームワークやライブラリを追加導入した場合は、その選定意図の解説資料
- (Optional) 検証用テストコードの導入
- (Optional) 型検査など、静的解析を行うための仕組みの導入

## 3rd Party のフレームワークやライブラリを追加導入した場合は、その選定意図の解説資料
### Laravel
- 選定意図:
  - 機能性: MVCアーキテクチャの提供、豊富な機能、Eloquent ORMによるデータベース操作の簡便化。
  - 拡張性と柔軟性: パッケージの導入が容易であり、拡張性が高い。
  - ドキュメントも充実。
  - セキュリティ: CSRF保護や暗号化機能などのセキュリティ機能が組み込まれている。
  - 実務での使用経験がある


### React
- 選定意図:
  - 機能性:
    - 高度なUI構築が可能、コンポーネントベースの開発スタイル。
  - ドキュメントの充実さ
  - 実務での使用経験がある

### Axios
- 選定意図:
  - 非同期HTTPリクエストの簡単な実装。

### Material-UI (MUI)
- 選定意図:
  - 高品質なReactコンポーネントライブラリ、カスタマイズ性が高い。
  - 詳細なドキュメント、豊富なサンプル。



## (Optional) 検証用テストコードの導入
- `ScheduleControllerTest.php`を作成

### 実行コマンド
`php artisan test`


## (Optional) 型検査など、静的解析を行うための仕組みの導入
- PHPStanを導入
### 実行コマンド
`vendor/bin/phpstan analyse`


## 仕様のメモ
- 未成年が含まれる場合は、20:00以降は入場できないようにする。





----


# 概念クラス図
<img width="550" alt="スクリーンショット 2024-07-13 23 15 35" src="https://github.com/user-attachments/assets/61faf63d-505e-468a-8c32-0e8d528a6488">
<img width="550" alt="スクリーンショット 2024-07-13 23 16 02" src="https://github.com/user-attachments/assets/a81d4c82-1e8e-443e-b296-e7d793272f45">
